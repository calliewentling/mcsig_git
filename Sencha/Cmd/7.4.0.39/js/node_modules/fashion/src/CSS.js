"use strict";

var Fashion = require('./export/Base.js'),
    Base = Fashion.Base;

var SourceBuilder = require('./type/SourceBuilder.js');
var CssPostprocessor = require('./CssPostprocessor.js');
var ExtendProcessor = require('./ExtendProcessor.js');
var PlaceholderProcessor = require('./PlaceholderProcessor.js');
var Ready = require('./Ready.js');

var Output = require('./export/Output.js');
var CompressedOutput = require('./CompressedOutput.js');

class CSS extends Base {
    constructor(config) {
        super(config);
        Fashion.apply(this, {
            css: [],
            extenders: [],
            outputs: []
        });
    }

    reset() {
        this.css = [];
    }

    resetOutputs() {
        this.outputs = [];
        this.output = null;
    }

    addRuleset(ruleset) {
        this.css.push(ruleset);
    }

    createOutput(compressed, indent, skipComments, split) {
        var output = compressed
            ? new CompressedOutput()
            : new Output();

        if (indent) {
            output.indentstr = indent;
        }

        if (!compressed && skipComments) {
            output.addComment = function (text) {
            };
            output.addCommentLn = function (text) {
                this.addln();
            }
        }

        if (split) {
            output.splitThreshold = split;
        }
        this.output = output;
        this.outputs.push(output);
        return output;
    }

    getOutputs() {
        var out = [];
        this.outputs.forEach((output) => {
            out.push(output.get().trim());
        });
        return out;
    }

    getText(callBack, compressed, indent, skipComments, split) {
        this.resetOutputs();
        var css = this.css,
            sourceBuilder = new SourceBuilder(),
            proc, extendProc, placeholderProc;

        proc = new CssPostprocessor({
            context: this.context
        });
        css = proc.process(css);

        extendProc = new ExtendProcessor();
        extendProc.context = this.context;
        extendProc.extendRulesets(css, this.extenders);

        placeholderProc = new PlaceholderProcessor();
        css = placeholderProc.processRulesets(css);

        // TODO: loop over all registered Type post-processors and allow
        // user defined transformations before css content generation


        // finally, hoist certain @-directives to the front.

        var hostDirectives = {
            '@charset': true,
            '@import': true
        };

        css.forEach((r, i) => r.index = i);

        css.sort((r1, r2) => {
            var d1 = !!hostDirectives[r1.atDirectiveName],
                d2 = !!hostDirectives[r2.atDirectiveName];

            if (d1 && !d2) {
                return -1;
            }

            if (d2 && !d1) {
                return 1;
            }

            if (d1 && d2) {
                if (r1.atDirectiveName != r2.atDirectiveName) {
                    if (r1.atDirectiveName === '@charset') {
                        return -1;
                    } else {
                        return 1;
                    }
                }
            }

            return r1.index - r2.index;
        });

        var me = this,
            processors = this.processors || [];

        function postProcess() {
            var proc = processors.shift(),
                ready;
            if (proc) {
                ready = new Ready();
                me.ready = ready;
                proc.execute(css, me);
                ready.onReady(function () {
                    postProcess();
                });
            } else {
                var output = me.createOutput(compressed, indent, skipComments, split);

                for (var c = 0; c < css.length; c++) {
                    var count = sourceBuilder.selectorCount,
                        len = output.output.length,
                        prevOutput = output.output,
                        newCount, newOutput;

                    sourceBuilder.toSource(css[c], output);
                    newCount = sourceBuilder.selectorCount;

                    if ((split > -1) && (newCount > split)) {
                        newOutput = me.createOutput(compressed, indent, skipComments, split);
                        newOutput.output = output.output.substring(len);
                        output.output = prevOutput;
                        sourceBuilder.selectorCount = newCount - count;
                        output = newOutput;
                    }
                }
                callBack(me.getOutputs(), me.exportFn);
            }
        }

        postProcess();
    }

    getJSON() {
        var ans = {};
        return ans;
    }
}

Fashion.apply(CSS.prototype, {
    css: undefined,
    extenders: undefined,
    outputs: undefined,
    output: undefined,
    processors: undefined,
    context: undefined,
    exportJs: undefined
});

module.exports = CSS;