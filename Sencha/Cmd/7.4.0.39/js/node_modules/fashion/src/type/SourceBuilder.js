"use strict";

var Fashion = require('../export/Base.js');
var TypeVisitor = require('./TypeVisitor.js');
var Output = require('../export/Output.js');
var BaseSourceBuilder = require('../export/type/SourceBuilder.js');

class SourceBuilder extends BaseSourceBuilder {
    constructor(cfg) {
        super(cfg);
        this.nullFound = false;
    }

    selectorlist(obj) {
        var items = obj.items,
            len = items.length,
            output = this.output,
            i;

        for (i = 0; i < len; i++) {
            this.visit(items[i]);
            if (i < len - 1) {
                output.add(',');
                output.addln();
                // we increment the selector count here, since
                // we actually want to skip one of the selectors in the
                // count, as all non-null ruleset.selectors values will
                // already have incremented the selector count by one
                // in the ruleset visitor method
                this.selectorCount++;
            }
        }
    }

    selectorproperty(obj) {
        this.visit(obj.property);
        this.output.add(': ');
        //this.output.space();
        this.visit(obj.value);
    }

    multipartselector(obj) {
        this.list(obj);
    }

    compoundselector(obj) {
        this.list(obj.sort());
    }

    selector(obj) {
        var parentSelector = obj.parent,
            output = this.output;

        switch (obj.selectorType) {
            case 'parent':
                if (parentSelector) {
                    this.visit(parent);
                    return false;
                }
                this.visit(obj.value);
                break;
            case 'placeholder':
                output.add('%');
                this.visit(obj.value);
                break;
            case 'dash':
                output.add('-');
                this.visit(obj.value);
                break;
            case 'attribute':
                output.add('[');
                this.visit(obj.value);
                output.add(']');
                break;
            case 'pseudo':
                output.add(':');
                this.visit(obj.value);
                break;
            default:
                this.visit(obj.value);
                break;
        }
    }

    declaration(obj) {
        var output = this.output,
            currDeclarationWas = this.currDeclaration,
            start = output.output,
            nullFoundWas = this.nullFound,
            prev;

        if (obj.docs && obj.docs.length) {
            for (var d = 0; d < obj.docs.length; d++) {
                output.addCommentLn(obj.docs[d]);
            }
        }

        this.currDeclaration = obj;

        output.addln();
        output.add(obj.property);
        output.add(":");
        output.space();
        prev = output.output.length;
        this.nullFound = false;
        this.visit(obj.value);
        if (this.nullFound || (output.output.length === prev && obj.property.indexOf('--') !== 0)) {
            output.output = start;
        }
        else {
            if (obj.important) {
                output.add(' !important');
            }
            if (output.isCompressed) {
                // for compressed output, don't need to print the ';'
                // char for the last ruleset
                if (!obj.ruleset || obj !== obj.ruleset.lastDeclaration()) {
                    output.add(';');
                }
            } else {
                output.add(';');
            }
        }
        this.nullFound = nullFoundWas;
        this.currDeclaration = currDeclarationWas;
    }

    ruleset(obj) {
        var output = this.output,
            start = output.output,
            emptyStart;

        if (obj.isAtDirective) {
            output.addln();
            output.add(obj.atDirectiveName);
            output.add(' ');
            if (obj.atDirectiveValue) {
                this.visit(obj.atDirectiveValue);
                output.add(';');
            }
            else {
                output.add('{}');
            }
            return;
        }

        if (obj.selectors) {
            output.addln();

            if (obj.sourceInfo) {
                output.addComment('/* ' + obj.sourceInfo + ' */');
                output.addln();
            }

            if (obj.docs && obj.docs.length) {
                for (var d = 0; d < obj.docs.length; d++) {
                    output.addCommentLn(obj.docs[d]);
                }
            }
            this.selectorCount++;

            this.visit(obj.selectors);

            if (obj.isAtRule() &&
                obj.declarations.length === 0 &&
                obj.children.length === 0 && !obj.hasBlock) {
                output.add(";");
                return;
            }

            output.space();
            output.add('{');
            output.indent();
            emptyStart = output.output.length;

            this.visit(obj.declarations);

            if (obj.isAtRule() && !obj.isAtRoot()) {
                this.visit(obj.children);
                output.unindent();
                output.addln('}');
            }

            else {
                output.unindent();
                if (output.output.length === emptyStart) {
                    output.output = start;
                }
                else {
                    output.addln('}');
                }
                this.visit(obj.children);
            }
        }
    }
    
    visit(obj) {
        if (obj == null || obj.$isFashionNull) {
            this.nullFound = true;
        }
        else {
            super.visit(obj);
        }
    }

}

SourceBuilder.toSource = function(obj, output) {
    var sb = new SourceBuilder();
    return sb.toSource(obj, output);
};

Fashion.apply(SourceBuilder.prototype, {
    output: null,
    selectorCount: 0,
    currDeclaration: null
});

module.exports = SourceBuilder;