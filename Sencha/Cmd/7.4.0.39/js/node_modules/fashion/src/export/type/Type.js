/*
 * Copyright (c) 2012-2016. Sencha Inc.
 */

"use strict";

var Fashion = require('../Base.js');

class Type {
    coerce(obj) {
        var converted = this.tryCoerce(obj);
        return converted || obj;
    }

    _getHash() {
        if (this.visitTarget) {
            return this.visitTarget.toString();
        }
        return this.toString();

    }

    getHash() {
        if (this._hash == null) {
            this._hash = this._getHash();
        }
        return this._hash;
    }

    tryCoerce(obj) {
        var me = this;

        if (me.constructor === obj.constructor) {
            return obj;
        }

        if (me.constructor.tryCoerce) {
            return me.constructor.tryCoerce(obj);
        }

        return undefined;
    }

    supports(prefix) {
        return false;
    }

    operate(operation, right) {
        return this.performOperation(operation, this.coerce(right));
    }

    performOperation(operation, right) {
        // check for <op>.<type> name for class-specific impl,
        // eg, ==.color or +.list
        var method = this[operation + "." + right.type] || this[operation];

        if (!method) {
            Fashion.raise("Failed to find method for operation " + operation + " on type " +
                right.type + " with value " + right + ".");

        }

        var res = method.call(this, right);

        if (!res || !res.$isFashionType) {
            res = Type.box(res);
        }

        return res;
    }

    '=='(right) {
        return this.getHash() === right.getHash();
    }

    '!='(right) {
        return this.getHash() !== right.getHash();
    }

    '>='(right) {
        return this.getHash() >= right.getHash();
    }

    '<='(right) {
        return this.getHash() <= right.getHash();
    }

    '>'(right) {
        return this.getHash() > right.getHash();
    }

    '<'(right) {
        return this.getHash() < right.getHash();
    }

    '+'(right) {
        return this.getHash() + right.getHash();
    }

    copy() {
        return this;
    }

    matches(match) {
        if (match && match == this.toString()) {
            return true;
        }
        return false;
    }

    clone(match, replace) {
        if (replace && this.matches(match)) {
            return replace.copy();
        }
        var copy = this.copy();
        copy.ast = this.ast;
        copy.$referenceName = this.$referenceName;
        copy.$referenceBase = this.$referenceBase;
        copy.$previousReference = this.$previousReference;
        return copy;
    }

    unquote() {
        return this;
    }

    toPrefixedString(prefix) {
        return this.toString();
    }

    doVisit(visitor) {
    }

    descend(visitoir) {
    }

    /**
     * A mechanism that enables searching upwards in the type tree for comments with a
     * particular control tag.  The search begins locally first on the specified node,
     * and continues upwards until either an enable or disable tag is specified, or the
     * the root of the tree is reached with no tags specified.
     *
     * By testing for both positive and negative matches locally, features can be enabled
     * or disabled at specific points, potentially overriding state set at a more
     * generic scope.  Ex:
     *
     *      //# fashion -ingline
     *      @font-face {
     *          src: url(foo.eot);
     *          src: url(foo.svg);
     *          //# fashion +inline
     *          src: url(foo.ttf);
     *      }
     *
     * @param tag The tag to search for.
     * @param prefix An optional prefix, such as 'fashion warn'.  Defaults to 'fashion'
     * @param enable A regex indicating a match for the enable state (+tag).
     * @param disable A regex indicating a match for the disable state (-tag)
     * @returns {any} true for enable | false for disable | null for unspecified
     */
    hasTag(tag, prefix, enable, disable) {
        prefix = prefix || "fashion";
        enable = enable || new RegExp('^\\s*//#\\s*' + prefix + '\\s*\\+?' + tag + "\\s*$");
        disable = disable || new RegExp('^\\s*//#\\s*' + prefix + '\\s*\\-' + tag + '\\s*$');
        var docs = this.docs;
        if (docs && docs.length) {
            for (var d = 0; d < this.docs.length; d++) {
                var doc = docs[d];
                if (enable.test(doc)) {
                    return true;
                }
                if (disable.test(doc)) {
                    return false;
                }
            }
        }

        if (this.parentNode) {
            return this.parentNode.hasTag(tag, prefix, enable, disable);
        }

        return null;
    }

    toDisplayString() {
        return '[' + this.constructor.name + ' : ' + this.toString() + ']';
    }
}

Fashion.apply(Type.prototype, {
    visitTarget: undefined,
    $isFashionType: true,
    $canUnbox: true,

    $isFashionLiteral: false,
    $isFashionNumber: false,
    $isFashionString: false,
    $isFashionBool: false,

    $constant: false,

    /**
     * if this value is a global variable, this field will store the global
     * variable name by which this value is referenced.
     */
    $referenceName: undefined,

    $referenceBase: undefined,
    $previousReference: undefined,

    value: undefined,
    unit: undefined,
    parentNode: undefined,
    docs: undefined,
    ast: undefined
});

module.exports = Type;
