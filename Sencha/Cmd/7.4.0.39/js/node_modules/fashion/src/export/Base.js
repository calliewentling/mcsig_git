/*
 * Copyright (c) 2012-2016. Sencha Inc.
 */

"use strict";

var NameConverter = require('./../NameConverter.js');

var debugging = {
    trace: false
};

class Base {
    constructor(config) {
        if (config) {
            merge(this, config);
        }
    }
}

class BaseSet {
    first() {
        return first(this.items);
    }

    last() {
        return last(this.items);
    }

    tail() {
        return tail(this.items);
    }
}

BaseSet.prototype.items = null;

function _chainFunc() {
}

function apply(target, source) {
    target = target || {};

    if (source) {
        for (var name in source) {
            target[name] = source[name];
        }
    }

    return target;
}

function merge(destination, object) {
    destination = destination || {};
    var key, value, sourceKey;

    if (object) {
        for (key in object) {
            value = object[key];
            if (value && value.constructor === Object) {
                sourceKey = destination[key];
                if (sourceKey && sourceKey.constructor === Object) {
                    merge(sourceKey, value);
                } else {
                    destination[key] = value;
                }
            } else {
                destination[key] = value;
            }
        }
    }

    return destination;
}

var chain = Object.create || function (Parent) {
        _chainFunc.prototype = Parent;
        return new _chainFunc();
    };

function createMessage(message, source) {
    if (source && source.isFashionScanner) {
        message += ': ' + source.currentFile + ':' + source.lineNumber;
    } else if (source) {
        message += ': ' + source.file + ':' + source.lineNumber;
    }

    return message;
}

function isFunction(obj) {
    return obj && typeof obj === 'function';
}

function trace(message, source) {
    if (debugging.trace) {
        console.log(createMessage('[DBG] ' + message, source));
    }
}

function debug(message, source) {
    console.log(createMessage('[DBG] ' + message, source));
}

function log(message, source) {
    console.log(createMessage('[LOG] ' + message, source));
}

function info(message, source) {
    console.log(createMessage('[INF] ' + message, source));
}

function warn(message, source) {
    console.log(createMessage('[WRN] ' + message, source));
}

function error(message, source) {
    console.log(createMessage('[ERR] ' + message, source));
}

function raise(message, extra) {
    if (Fashion.inspect) {
        debugger;
    }
    
    if (typeof message !== 'string') {
        extra = message;
        message = extra.message;
        delete extra.message;
    }
    
    var error = new Error(message);
    error.$isFashionError = true;
    throw apply(error, extra);
}

function raiseAt(message, source, stack) {
    var extra;

    if (source) {
        message = createMessage(message, source);

        if (source.isFashionScanner) {
            extra = {
                file: source.currentFile,
                lineNumber: source.lineNumber
            };
        } else {
            extra = {
                node: source,
                lineNumber: source.lineNumber,
                file: source.file
            };
        }
    }

    if (stack) {
        if (!extra) {
            extra = {};
        }
        extra.fashionStack = stack;
    }

    raise(message, extra);
}

function filter(array, func) {
    var result = [];
    for (var i = 0; i < array.length; i++) {
        var item = array[i];
        if (func(item, i)) {
            result.push(item);
        }
    }
    return result;
}

function convert(array, func) {
    var converted = [];
    for (var i = 0; i < array.length; i++) {
        converted.push(func(array[i]));
    }
    return converted;
}

function first(array) {
    return array.length && array[0];
}

function last(array) {
    return array.length && array[array.length - 1];
}

function tail(array) {
    if (array.length > 2) {
        return array.slice(1);
    }
    return [];
}

function getAllKeys(obj, stop) {
    var keys = [],
        map = {},
        i, key, n, names;

    for (; obj && obj !== stop; obj = Object.getPrototypeOf(obj)) {
        names = Object.getOwnPropertyNames(obj);

        for (i = 0, n = names.length; i < n; ++i) {
            key = names[i];

            if (!map[key]) {
                map[key] = true;
                keys.push(key);
            }
        }

    }

    return keys;
}

function mixin(target, bases) {
    if (!Array.isArray(bases)) {
        bases = Array.prototype.slice.call(arguments, 1);
    }

    var proto = target.prototype;

    for (var b = 0; b < bases.length; b++) {
        var base = bases[b],
            baseProto = base.prototype;

        getAllKeys(baseProto, Base.prototype).forEach(function (name) {
            if (name in baseProto) {
                if (!(name in proto)) {
                    proto[name] = baseProto[name];
                }
            }
        });
    }
}

function flatten(array, level, output) {
    output = output || [];
    level = typeof level === 'undefined' ? 1000 : level;

    for (var i = 0; i < array.length; i++) {
        var item = array[i];
        if (Array.isArray(item) && level) {
            flatten(item, level - 1, output);
        } else {
            output.push(item);
        }
    }
    return output;
}

module.exports = {
    EmptyArray: [],
    getJsName: NameConverter.getJsName,
    chain: chain,
    Base: Base,
    BaseSet: BaseSet,
    apply: apply,
    merge: merge,
    createMessage: createMessage,
    isFunction: isFunction,
    debugging: debugging,
    trace: trace,
    debug: debug,
    log: log,
    info: info,
    warn: warn,
    error: error,
    raise: raise,
    raiseAt: raiseAt,
    filter: filter,
    convert: convert,
    first: first,
    last: last,
    tail: tail,
    mixin: mixin,
    flatten: flatten
};


