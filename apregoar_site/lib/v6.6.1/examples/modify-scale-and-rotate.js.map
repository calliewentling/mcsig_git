{"version":3,"sources":["webpack:///./modify-scale-and-rotate.js"],"names":["raster","source","style","geometry","feature","const","modifyGeometry","get","getGeometry","fill","color","stroke","width","image","radius","calculateCenter","let","center","coordinates","minRadius","sqDistances","type","getType","x","y","i","getCoordinates","slice","forEach","coordinate","getCoordinateAt","getExtent","map","dx","dy","Math","sqrt","max","apply","draw","vector","styles","result","push","rsq","points","filter","index","layers","target","view","zoom","defaultStyle","getOverlay","getStyleFunction","modify","condition","event","deleteCondition","insertVertexCondition","modifyFeature","point","modifyPoint","geometry0","initialRadius","initialAngle","atan2","currentRadius","currentAngle","clone","scale","undefined","rotate","on","features","set","setGeometry","unset","addInteraction","typeSelect","document","getElementById","addInteractions","value","onchange","removeInteraction"],"mappings":"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","file":"modify-scale-and-rotate.js","sourcesContent":["import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {Circle as CircleStyle, Fill, Stroke, Style} from '../src/ol/style.js';\nimport {Draw, Modify, Translate} from '../src/ol/interaction.js';\nimport {MultiPoint, Point} from '../src/ol/geom.js';\nimport {OSM, Vector as VectorSource} from '../src/ol/source.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\nimport {getCenter, getHeight, getWidth} from '../src/ol/extent.js';\nimport {\n  never,\n  platformModifierKeyOnly,\n  primaryAction,\n} from '../src/ol/events/condition.js';\n\nconst raster = new TileLayer({\n  source: new OSM(),\n});\n\nconst source = new VectorSource();\n\nconst style = new Style({\n  geometry: function (feature) {\n    const modifyGeometry = feature.get('modifyGeometry');\n    return modifyGeometry ? modifyGeometry.geometry : feature.getGeometry();\n  },\n  fill: new Fill({\n    color: 'rgba(255, 255, 255, 0.2)',\n  }),\n  stroke: new Stroke({\n    color: '#ffcc33',\n    width: 2,\n  }),\n  image: new CircleStyle({\n    radius: 7,\n    fill: new Fill({\n      color: '#ffcc33',\n    }),\n  }),\n});\n\nfunction calculateCenter(geometry) {\n  let center, coordinates, minRadius;\n  const type = geometry.getType();\n  if (type === 'Polygon') {\n    let x = 0;\n    let y = 0;\n    let i = 0;\n    coordinates = geometry.getCoordinates()[0].slice(1);\n    coordinates.forEach(function (coordinate) {\n      x += coordinate[0];\n      y += coordinate[1];\n      i++;\n    });\n    center = [x / i, y / i];\n  } else if (type === 'LineString') {\n    center = geometry.getCoordinateAt(0.5);\n    coordinates = geometry.getCoordinates();\n  } else {\n    center = getCenter(geometry.getExtent());\n  }\n  let sqDistances;\n  if (coordinates) {\n    sqDistances = coordinates.map(function (coordinate) {\n      const dx = coordinate[0] - center[0];\n      const dy = coordinate[1] - center[1];\n      return dx * dx + dy * dy;\n    });\n    minRadius = Math.sqrt(Math.max.apply(Math, sqDistances)) / 3;\n  } else {\n    minRadius =\n      Math.max(\n        getWidth(geometry.getExtent()),\n        getHeight(geometry.getExtent())\n      ) / 3;\n  }\n  return {\n    center: center,\n    coordinates: coordinates,\n    minRadius: minRadius,\n    sqDistances: sqDistances,\n  };\n}\n\nconst vector = new VectorLayer({\n  source: source,\n  style: function (feature) {\n    const styles = [style];\n    const modifyGeometry = feature.get('modifyGeometry');\n    const geometry = modifyGeometry\n      ? modifyGeometry.geometry\n      : feature.getGeometry();\n    const result = calculateCenter(geometry);\n    const center = result.center;\n    if (center) {\n      styles.push(\n        new Style({\n          geometry: new Point(center),\n          image: new CircleStyle({\n            radius: 4,\n            fill: new Fill({\n              color: '#ff3333',\n            }),\n          }),\n        })\n      );\n      const coordinates = result.coordinates;\n      if (coordinates) {\n        const minRadius = result.minRadius;\n        const sqDistances = result.sqDistances;\n        const rsq = minRadius * minRadius;\n        const points = coordinates.filter(function (coordinate, index) {\n          return sqDistances[index] > rsq;\n        });\n        styles.push(\n          new Style({\n            geometry: new MultiPoint(points),\n            image: new CircleStyle({\n              radius: 4,\n              fill: new Fill({\n                color: '#33cc33',\n              }),\n            }),\n          })\n        );\n      }\n    }\n    return styles;\n  },\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: 'map',\n  view: new View({\n    center: [-11000000, 4600000],\n    zoom: 4,\n  }),\n});\n\nconst defaultStyle = new Modify({source: source})\n  .getOverlay()\n  .getStyleFunction();\n\nconst modify = new Modify({\n  source: source,\n  condition: function (event) {\n    return primaryAction(event) && !platformModifierKeyOnly(event);\n  },\n  deleteCondition: never,\n  insertVertexCondition: never,\n  style: function (feature) {\n    feature.get('features').forEach(function (modifyFeature) {\n      const modifyGeometry = modifyFeature.get('modifyGeometry');\n      if (modifyGeometry) {\n        const point = feature.getGeometry().getCoordinates();\n        let modifyPoint = modifyGeometry.point;\n        if (!modifyPoint) {\n          // save the initial geometry and vertex position\n          modifyPoint = point;\n          modifyGeometry.point = modifyPoint;\n          modifyGeometry.geometry0 = modifyGeometry.geometry;\n          // get anchor and minimum radius of vertices to be used\n          const result = calculateCenter(modifyGeometry.geometry0);\n          modifyGeometry.center = result.center;\n          modifyGeometry.minRadius = result.minRadius;\n        }\n\n        const center = modifyGeometry.center;\n        const minRadius = modifyGeometry.minRadius;\n        let dx, dy;\n        dx = modifyPoint[0] - center[0];\n        dy = modifyPoint[1] - center[1];\n        const initialRadius = Math.sqrt(dx * dx + dy * dy);\n        if (initialRadius > minRadius) {\n          const initialAngle = Math.atan2(dy, dx);\n          dx = point[0] - center[0];\n          dy = point[1] - center[1];\n          const currentRadius = Math.sqrt(dx * dx + dy * dy);\n          if (currentRadius > 0) {\n            const currentAngle = Math.atan2(dy, dx);\n            const geometry = modifyGeometry.geometry0.clone();\n            geometry.scale(currentRadius / initialRadius, undefined, center);\n            geometry.rotate(currentAngle - initialAngle, center);\n            modifyGeometry.geometry = geometry;\n          }\n        }\n      }\n    });\n    return defaultStyle(feature);\n  },\n});\n\nmodify.on('modifystart', function (event) {\n  event.features.forEach(function (feature) {\n    feature.set(\n      'modifyGeometry',\n      {geometry: feature.getGeometry().clone()},\n      true\n    );\n  });\n});\n\nmodify.on('modifyend', function (event) {\n  event.features.forEach(function (feature) {\n    const modifyGeometry = feature.get('modifyGeometry');\n    if (modifyGeometry) {\n      feature.setGeometry(modifyGeometry.geometry);\n      feature.unset('modifyGeometry', true);\n    }\n  });\n});\n\nmap.addInteraction(modify);\nmap.addInteraction(\n  new Translate({\n    condition: function (event) {\n      return primaryAction(event) && platformModifierKeyOnly(event);\n    },\n    layers: [vector],\n  })\n);\n\nlet draw; // global so we can remove it later\nconst typeSelect = document.getElementById('type');\n\nfunction addInteractions() {\n  draw = new Draw({\n    source: source,\n    type: typeSelect.value,\n  });\n  map.addInteraction(draw);\n}\n\n/**\n * Handle change event.\n */\ntypeSelect.onchange = function () {\n  map.removeInteraction(draw);\n  addInteractions();\n};\n\naddInteractions();\n"],"sourceRoot":""}