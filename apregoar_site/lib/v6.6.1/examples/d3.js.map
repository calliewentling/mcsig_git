{"version":3,"sources":["webpack:///./d3.js"],"names":["CanvasLayer","options","super","this","features","svg","d3","select","document","createElement","append","style","datum","attr","getSourceState","render","frameState","const","width","size","height","projection","viewState","d3Projection","geoMercator","scale","translate","d3Path","geoPath","pixelBounds","bounds","pixelBoundsWidth","pixelBoundsHeight","geoBounds","geoBoundsLeftBottom","geoBoundsRightTop","geoBoundsWidth","getExtent","widthResolution","heightResolution","Math","max","resolution","center","extent","angle","rotation","PI","node","map","layers","source","layer","target","view","zoom","json","then","us","topojson","feature","objects","counties","addLayer"],"mappings":"2KAQMA,EAAyB,YAC7B,WAAYC,GACVC,OAAM,KAAAD,GAENE,KAAKC,SAAWH,EAAQG,SAExBD,KAAKE,IAAMC,GACRC,OAAOC,SAASC,cAAc,QAC9BC,OAAO,OACPC,MAAM,WAAY,YAErBR,KAAKE,IAAIK,OAAO,QAAQE,MAAMT,KAAKC,UAAUS,KAAK,QAAS,Y,8FAG7D,EAAF,UAAEC,eAAA,WACE,OAAO,WAGT,EAAF,UAAEC,OAAA,SAAOC,GACLC,IAAMC,EAAQF,EAAWG,KAAK,GACxBC,EAASJ,EAAWG,KAAK,GACzBE,EAAaL,EAAWM,UAAUD,WAClCE,EAAejB,GAAGkB,cAAcC,MAAM,GAAGC,UAAU,CAAC,EAAG,IACzDC,EAASrB,GAAGsB,UAAUP,WAAWE,GAE/BM,EAAcF,EAAOG,OAAO3B,KAAKC,UACjC2B,EAAmBF,EAAY,GAAG,GAAKA,EAAY,GAAG,GACtDG,EAAoBH,EAAY,GAAG,GAAKA,EAAY,GAAG,GAEvDI,EAAY3B,GAAG2B,UAAU9B,KAAKC,UAC9B8B,GAAsB,QAAWD,EAAU,GAAIZ,GAC/Cc,GAAoB,QAAWF,EAAU,GAAIZ,GAC/Ce,EAAiBD,EAAkB,GAAKD,EAAoB,GAC5DE,EAAiB,IACnBA,IAAkB,QAASf,EAAWgB,cAExCpB,IAEMqB,EAAkBF,EAAiBL,EACnCQ,GAHkBJ,EAAkB,GAAKD,EAAoB,IAGxBF,EAErCP,EADIe,KAAKC,IAAIH,EAAiBC,GAClBvB,EAAWM,UAAUoB,WAEjCC,GAAS,SAAS,QAAU3B,EAAW4B,QAASvB,GAChDwB,EAA0C,KAAhC7B,EAAWM,UAAUwB,SAAkBN,KAAKO,GAgB5D,OAdAxB,EACGE,MAAMA,GACNkB,OAAOA,GACPjB,UAAU,CAACR,EAAQ,EAAGE,EAAS,IAC/ByB,MAAMA,IAETlB,EAASA,EAAON,WAAWE,IACpBpB,KAAKC,UAEZD,KAAKE,IAAIQ,KAAK,QAASK,GACvBf,KAAKE,IAAIQ,KAAK,SAAUO,GAExBjB,KAAKE,IAAIE,OAAO,QAAQM,KAAK,IAAKc,GAE3BxB,KAAKE,IAAI2C,Q,EA5DW,CAAL,KAgEpBC,EAAM,IAAI,IAAI,CAClBC,OAAQ,CACN,IAAI,IAAU,CACZC,OAAQ,IAAI,IAAO,CACjBC,MAAO,kBAIbC,OAAQ,MACRC,KAAM,IAAI,KAAK,CACbX,QAAQ,QAAW,EAAE,GAAI,KACzBY,KAAM,MAOVjD,GAAGkD,KAAK,yBAAyBC,MAAK,SAAUC,GAC9CzC,IAAMmC,EAAQ,IAAIpD,EAAY,CAC5BI,SAAUuD,SAASC,QAAQF,EAAIA,EAAGG,QAAQC,YAG5Cb,EAAIc,SAASX,Q","file":"d3.js","sourcesContent":["import Map from '../src/ol/Map.js';\nimport SourceState from '../src/ol/source/State.js';\nimport Stamen from '../src/ol/source/Stamen.js';\nimport View from '../src/ol/View.js';\nimport {Layer, Tile as TileLayer} from '../src/ol/layer.js';\nimport {fromLonLat, toLonLat} from '../src/ol/proj.js';\nimport {getCenter, getWidth} from '../src/ol/extent.js';\n\nclass CanvasLayer extends Layer {\n  constructor(options) {\n    super(options);\n\n    this.features = options.features;\n\n    this.svg = d3\n      .select(document.createElement('div'))\n      .append('svg')\n      .style('position', 'absolute');\n\n    this.svg.append('path').datum(this.features).attr('class', 'boundary');\n  }\n\n  getSourceState() {\n    return SourceState.READY;\n  }\n\n  render(frameState) {\n    const width = frameState.size[0];\n    const height = frameState.size[1];\n    const projection = frameState.viewState.projection;\n    const d3Projection = d3.geoMercator().scale(1).translate([0, 0]);\n    let d3Path = d3.geoPath().projection(d3Projection);\n\n    const pixelBounds = d3Path.bounds(this.features);\n    const pixelBoundsWidth = pixelBounds[1][0] - pixelBounds[0][0];\n    const pixelBoundsHeight = pixelBounds[1][1] - pixelBounds[0][1];\n\n    const geoBounds = d3.geoBounds(this.features);\n    const geoBoundsLeftBottom = fromLonLat(geoBounds[0], projection);\n    const geoBoundsRightTop = fromLonLat(geoBounds[1], projection);\n    let geoBoundsWidth = geoBoundsRightTop[0] - geoBoundsLeftBottom[0];\n    if (geoBoundsWidth < 0) {\n      geoBoundsWidth += getWidth(projection.getExtent());\n    }\n    const geoBoundsHeight = geoBoundsRightTop[1] - geoBoundsLeftBottom[1];\n\n    const widthResolution = geoBoundsWidth / pixelBoundsWidth;\n    const heightResolution = geoBoundsHeight / pixelBoundsHeight;\n    const r = Math.max(widthResolution, heightResolution);\n    const scale = r / frameState.viewState.resolution;\n\n    const center = toLonLat(getCenter(frameState.extent), projection);\n    const angle = (-frameState.viewState.rotation * 180) / Math.PI;\n\n    d3Projection\n      .scale(scale)\n      .center(center)\n      .translate([width / 2, height / 2])\n      .angle(angle);\n\n    d3Path = d3Path.projection(d3Projection);\n    d3Path(this.features);\n\n    this.svg.attr('width', width);\n    this.svg.attr('height', height);\n\n    this.svg.select('path').attr('d', d3Path);\n\n    return this.svg.node();\n  }\n}\n\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: new Stamen({\n        layer: 'watercolor',\n      }),\n    }),\n  ],\n  target: 'map',\n  view: new View({\n    center: fromLonLat([-97, 38]),\n    zoom: 4,\n  }),\n});\n\n/**\n * Load the topojson data and create an ol/layer/Image for that data.\n */\nd3.json('data/topojson/us.json').then(function (us) {\n  const layer = new CanvasLayer({\n    features: topojson.feature(us, us.objects.counties),\n  });\n\n  map.addLayer(layer);\n});\n"],"sourceRoot":""}