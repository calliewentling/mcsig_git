{"version":3,"sources":["webpack:///../src/ol/format/WKB.js","webpack:///./wkb.js"],"names":["WKBGeometryType","WkbReader","view","this","view_","pos_","initialized_","isLittleEndian_","hasZ_","hasM_","srid_","layout_","GeometryLayout","readUint8","getUint8","readUint32","isLittleEndian","getUint32","undefined","readDouble","getFloat64","readPoint","const","coords","push","readLineString","numPoints","i","readPolygon","numRings","rings","readWkbHeader","expectedTypeId","wkbType","wkbTypeThousandth","Math","floor","hasZ","Boolean","hasM","hasSRID","typeId","layout","join","srid","Error","readWkbPayload","readMultiPoint","readMultiLineString","readMultiPolygon","readGeometryCollection","readWkbBlock","readWkbCollection","reader","num","items","result","call","readGeometry","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection","getSrid","WkbWriter","opts","littleEndian","isEWKB_","ewkb","writeQueue_","nodata_","X","Y","Z","M","nodata","getDataView","source","text","buffer","Uint8Array","length","parseInt","substr","DataView","decodeHexString","ArrayBuffer","isView","byteOffset","byteLength","writeUint8","value","writeUint32","writeDouble","writePoint","coordsObj","split","map","axis","idx","writeLineString","let","writePolygon","writeWkbHeader","indexOf","Number","isInteger","writeMultiPoint","writeMultiLineString","writeMultiPolygon","writeGeometryCollection","geometries","writeGeometry","findMinimumLayout","geom","a","b","SimpleGeometry","getLayout","geoms","getGeometriesArray","wkblut","GeometryType","geomType","getType","writerLUT","getCoordinates","getBuffer","reduce","acc","item","pos","forEach","setUint8","setUint32","setFloat64","opt_options","super","options","splitCollection","viewCache_","hex_","hex","littleEndian_","ewkb_","geometryLayout","nodataZ_","nodataZ","nodataM_","nodataM","FormatType","readFeature","Feature","geometry","readFeatures","getReadOptions","readProjection","writeFeature","feature","getGeometry","writeFeatures","features","f","adaptOptions","writer","dataProjection","code","getCode","substring","Array","from","values","x","toString","toUpperCase","encodeHexString","raster","Tile","OSM","featureProjection","vector","Vector","Map","layers","target","View","center","zoom"],"mappings":"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","file":"wkb.js","sourcesContent":["/**\n * @module ol/format/WKB\n */\nimport Feature from '../Feature.js';\nimport FeatureFormat, {transformGeometryWithOptions} from './Feature.js';\nimport FormatType from './FormatType.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\n\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport {assign} from '../obj.js';\n\n// WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n\n/**\n * @const\n * @enum {number}\n */\nconst WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n\n  /*\n  CIRCULAR_STRING: 8,\n  COMPOUND_CURVE: 9,\n  CURVE_POLYGON: 10,\n\n  MULTI_CURVE: 11,\n  MULTI_SURFACE: 12,\n  CURVE: 13,\n  SURFACE: 14,\n  */\n\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17,\n};\n\nclass WkbReader {\n  /**\n   * @param {DataView} view source to read\n   */\n  constructor(view) {\n    this.view_ = view;\n    this.pos_ = 0;\n\n    this.initialized_ = false;\n    this.isLittleEndian_ = false;\n    this.hasZ_ = false;\n    this.hasM_ = false;\n    /** @type {number} */\n    this.srid_ = null;\n\n    this.layout_ = GeometryLayout.XY;\n  }\n\n  /**\n   * @return {number} value\n   */\n  readUint8() {\n    return this.view_.getUint8(this.pos_++);\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readUint32(isLittleEndian) {\n    return this.view_.getUint32(\n      (this.pos_ += 4) - 4,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readDouble(isLittleEndian) {\n    return this.view_.getFloat64(\n      (this.pos_ += 8) - 8,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @return {import('../coordinate.js').Coordinate} coords for Point\n   */\n  readPoint() {\n    /** @type import('../coordinate.js').Coordinate */\n    const coords = [];\n\n    coords.push(this.readDouble());\n    coords.push(this.readDouble());\n    if (this.hasZ_) {\n      coords.push(this.readDouble());\n    }\n    if (this.hasM_) {\n      coords.push(this.readDouble());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n   */\n  readLineString() {\n    const numPoints = this.readUint32();\n\n    /** @type Array<import('../coordinate.js').Coordinate> */\n    const coords = [];\n    for (let i = 0; i < numPoints; i++) {\n      coords.push(this.readPoint());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n   */\n  readPolygon() {\n    const numRings = this.readUint32();\n\n    /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n    const rings = [];\n    for (let i = 0; i < numRings; i++) {\n      rings.push(this.readLineString()); // as a LinearRing\n    }\n\n    return rings;\n  }\n\n  /**\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {number} WKB Type ID\n   */\n  readWkbHeader(expectedTypeId) {\n    const byteOrder = this.readUint8();\n    const isLittleEndian = byteOrder > 0;\n\n    const wkbType = this.readUint32(isLittleEndian);\n    const wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n    const hasZ =\n      Boolean(wkbType & 0x80000000) ||\n      wkbTypeThousandth === 1 ||\n      wkbTypeThousandth === 3;\n    const hasM =\n      Boolean(wkbType & 0x40000000) ||\n      wkbTypeThousandth === 2 ||\n      wkbTypeThousandth === 3;\n    const hasSRID = Boolean(wkbType & 0x20000000);\n    const typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n    const layout = ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('');\n\n    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n\n    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n      throw new Error('Unexpected WKB geometry type ' + typeId);\n    }\n\n    if (this.initialized_) {\n      // sanity checks\n      if (this.isLittleEndian_ !== isLittleEndian) {\n        throw new Error('Inconsistent endian');\n      }\n      if (this.layout_ !== layout) {\n        throw new Error('Inconsistent geometry layout');\n      }\n      if (srid && this.srid_ !== srid) {\n        throw new Error('Inconsistent coordinate system (SRID)');\n      }\n    } else {\n      this.isLittleEndian_ = isLittleEndian;\n      this.hasZ_ = hasZ;\n      this.hasM_ = hasM;\n      this.layout_ = layout;\n      this.srid_ = srid;\n      this.initialized_ = true;\n    }\n\n    return typeId;\n  }\n\n  /**\n   * @param {number} typeId WKB Type ID\n   * @return {any} values read\n   */\n  readWkbPayload(typeId) {\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return this.readPoint();\n\n      case WKBGeometryType.LINE_STRING:\n        return this.readLineString();\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return this.readPolygon();\n\n      case WKBGeometryType.MULTI_POINT:\n        return this.readMultiPoint();\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return this.readMultiLineString();\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return this.readMultiPolygon();\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return this.readGeometryCollection();\n\n      default:\n        throw new Error(\n          'Unsupported WKB geometry type ' + typeId + ' is found'\n        );\n    }\n  }\n\n  /**\n   * @param {number} expectedTypeId Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbBlock(expectedTypeId) {\n    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n  }\n\n  /**\n   * @param {Function} reader reader function for each item\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbCollection(reader, expectedTypeId) {\n    const num = this.readUint32();\n\n    const items = [];\n    for (let i = 0; i < num; i++) {\n      const result = reader.call(this, expectedTypeId);\n      if (result) {\n        items.push(result);\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n   */\n  readMultiPoint() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n   */\n  readMultiLineString() {\n    return this.readWkbCollection(\n      this.readWkbBlock,\n      WKBGeometryType.LINE_STRING\n    );\n  }\n\n  /**\n   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n   */\n  readMultiPolygon() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n  }\n\n  /**\n   * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n   */\n  readGeometryCollection() {\n    return this.readWkbCollection(this.readGeometry);\n  }\n\n  /**\n   * @return {import('../geom/Geometry.js').default} geometry\n   */\n  readGeometry() {\n    const typeId = this.readWkbHeader();\n    const result = this.readWkbPayload(typeId);\n\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return new Point(\n          /** @type {import('../coordinate.js').Coordinate} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.LINE_STRING:\n        return new LineString(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return new Polygon(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POINT:\n        return new MultiPoint(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return new MultiLineString(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return new MultiPolygon(\n          /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return new GeometryCollection(\n          /** @type {Array<import('../geom/Geometry.js').default>} */ (result)\n        );\n\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * @return {number} SRID in the EWKB. `null` if not defined.\n   */\n  getSrid() {\n    return this.srid_;\n  }\n}\n\nclass WkbWriter {\n  /**\n   * @type {object}\n   * @property {string} [layout] geometryLayout\n   * @property {boolean} [littleEndian=true] littleEndian\n   * @property {boolean} [ewkb=true] Whether writes in EWKB format\n   * @property {object} [nodata] NoData value for each axes\n   * @param {object} opts options\n   */\n  constructor(opts) {\n    opts = opts || {};\n\n    /** @type {string} */\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n\n    this.isEWKB_ = opts.ewkb !== false;\n\n    /** @type {Array<Array<number>>} */\n    this.writeQueue_ = [];\n\n    /**\n     * @type {object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} Z NoData value for Z\n     * @property {number} M NoData value for M\n     */\n    this.nodata_ = assign({X: 0, Y: 0, Z: 0, M: 0}, opts.nodata);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint8(value) {\n    this.writeQueue_.push([1, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint32(value) {\n    this.writeQueue_.push([4, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeDouble(value) {\n    this.writeQueue_.push([8, value]);\n  }\n\n  /**\n   * @param {import('../coordinate.js').Coordinate} coords coords\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n  writePoint(coords, layout) {\n    /**\n     * @type {object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} [Z] NoData value for Z\n     * @property {number} [M] NoData value for M\n     */\n    const coordsObj = assign.apply(\n      null,\n      layout.split('').map((axis, idx) => ({[axis]: coords[idx]}))\n    );\n\n    for (const axis of this.layout_) {\n      this.writeDouble(\n        axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]\n      );\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n  writeLineString(coords, layout) {\n    this.writeUint32(coords.length); // numPoints\n    for (let i = 0; i < coords.length; i++) {\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n  writePolygon(rings, layout) {\n    this.writeUint32(rings.length); // numRings\n    for (let i = 0; i < rings.length; i++) {\n      this.writeLineString(rings[i], layout); // as a LinearRing\n    }\n  }\n\n  /**\n   * @param {number} wkbType WKB Type ID\n   * @param {number} [srid] SRID\n   */\n  writeWkbHeader(wkbType, srid) {\n    wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n    if (this.layout_.indexOf('Z') >= 0) {\n      wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n    }\n    if (this.layout_.indexOf('M') >= 0) {\n      wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n    }\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      wkbType |= 0x20000000;\n    }\n\n    this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n    this.writeUint32(wkbType);\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      this.writeUint32(srid);\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {string} layout layout\n   */\n  writeMultiPoint(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(1);\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n   * @param {string} layout layout\n   */\n  writeMultiLineString(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(2);\n      this.writeLineString(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n   * @param {string} layout layout\n   */\n  writeMultiPolygon(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(3);\n      this.writePolygon(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n   */\n  writeGeometryCollection(geometries) {\n    this.writeUint32(geometries.length); // numItems\n\n    for (let i = 0; i < geometries.length; i++) {\n      this.writeGeometry(geometries[i]);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {import(\"../geom/GeometryLayout.js\").default} [layout] layout\n   * @return {import(\"../geom/GeometryLayout.js\").default} minumum layout made by common axes\n   */\n  findMinimumLayout(geom, layout = GeometryLayout.XYZM) {\n    /**\n     * @param {import(\"../geom/GeometryLayout.js\").default} a A\n     * @param {import(\"../geom/GeometryLayout.js\").default} b B\n     * @return {import(\"../geom/GeometryLayout.js\").default} minumum layout made by common axes\n     */\n    const GeometryLayout_min = (a, b) => {\n      if (a === b) {\n        return a;\n      }\n\n      if (a === GeometryLayout.XYZM) {\n        // anything `b` is minimum\n        return b;\n      }\n      if (b === GeometryLayout.XYZM) {\n        // anything `a` is minimum\n        return a;\n      }\n\n      // otherwise, incompatible\n      return GeometryLayout.XY;\n    };\n\n    if (geom instanceof SimpleGeometry) {\n      return GeometryLayout_min(geom.getLayout(), layout);\n    }\n\n    if (geom instanceof GeometryCollection) {\n      const geoms = geom.getGeometriesArray();\n      for (let i = 0; i < geoms.length && layout !== GeometryLayout.XY; i++) {\n        layout = this.findMinimumLayout(geoms[i], layout);\n      }\n    }\n\n    return layout;\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {number} [srid] SRID\n   */\n  writeGeometry(geom, srid) {\n    const wkblut = {\n      [GeometryType.POINT]: WKBGeometryType.POINT,\n      [GeometryType.LINE_STRING]: WKBGeometryType.LINE_STRING,\n      [GeometryType.POLYGON]: WKBGeometryType.POLYGON,\n      [GeometryType.MULTI_POINT]: WKBGeometryType.MULTI_POINT,\n      [GeometryType.MULTI_LINE_STRING]: WKBGeometryType.MULTI_LINE_STRING,\n      [GeometryType.MULTI_POLYGON]: WKBGeometryType.MULTI_POLYGON,\n      [GeometryType.GEOMETRY_COLLECTION]: WKBGeometryType.GEOMETRY_COLLECTION,\n    };\n    const geomType = geom.getType();\n    const typeId = wkblut[geomType];\n\n    if (!typeId) {\n      throw new Error('GeometryType ' + geomType + ' is not supported');\n    }\n\n    // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n    if (!this.layout_) {\n      this.layout_ = this.findMinimumLayout(geom);\n    }\n\n    this.writeWkbHeader(typeId, srid);\n\n    if (geom instanceof SimpleGeometry) {\n      const writerLUT = {\n        [GeometryType.POINT]: this.writePoint,\n        [GeometryType.LINE_STRING]: this.writeLineString,\n        [GeometryType.POLYGON]: this.writePolygon,\n        [GeometryType.MULTI_POINT]: this.writeMultiPoint,\n        [GeometryType.MULTI_LINE_STRING]: this.writeMultiLineString,\n        [GeometryType.MULTI_POLYGON]: this.writeMultiPolygon,\n      };\n      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n    } else if (geom instanceof GeometryCollection) {\n      this.writeGeometryCollection(geom.getGeometriesArray());\n    }\n  }\n\n  getBuffer() {\n    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);\n    const buffer = new ArrayBuffer(byteLength);\n    const view = new DataView(buffer);\n\n    let pos = 0;\n    this.writeQueue_.forEach((item) => {\n      switch (item[0]) {\n        case 1:\n          view.setUint8(pos, item[1]);\n          break;\n        case 4:\n          view.setUint32(pos, item[1], this.isLittleEndian_);\n          break;\n        case 8:\n          view.setFloat64(pos, item[1], this.isLittleEndian_);\n          break;\n        default:\n          break;\n      }\n\n      pos += item[0];\n    });\n\n    return buffer;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/GeometryLayout\").default} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\nclass WKB extends FeatureFormat {\n  /**\n   * @param {Options} [opt_options] Optional configuration object.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    this.splitCollection = Boolean(options.splitCollection);\n\n    this.viewCache_ = null;\n\n    this.hex_ = options.hex !== false;\n    this.littleEndian_ = options.littleEndian !== false;\n    this.ewkb_ = options.ewkb !== false;\n\n    this.layout_ = options.geometryLayout; // null for auto detect\n    this.nodataZ_ = options.nodataZ || 0;\n    this.nodataM_ = options.nodataM || 0;\n\n    this.srid_ = options.srid;\n  }\n\n  /**\n   * @return {import(\"./FormatType.js\").default} Format.\n   */\n  getType() {\n    return this.hex_ ? FormatType.TEXT : FormatType.ARRAY_BUFFER;\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../Feature.js\").FeatureLike} Feature.\n   * @api\n   */\n  readFeature(source, opt_options) {\n    return new Feature({\n      geometry: this.readGeometry(source, opt_options),\n    });\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n  readFeatures(source, opt_options) {\n    let geometries = [];\n    const geometry = this.readGeometry(source, opt_options);\n    if (this.splitCollection && geometry instanceof GeometryCollection) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    return geometries.map((geometry) => new Feature({geometry}));\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, opt_options) {\n    const view = getDataView(source);\n    if (!view) {\n      return null;\n    }\n\n    const reader = new WkbReader(view);\n    const geometry = reader.readGeometry();\n\n    this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n    const options = this.getReadOptions(source, opt_options);\n    this.viewCache_ = null; // release\n\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   */\n  readProjection(source) {\n    const view = this.viewCache_ || getDataView(source);\n    if (!view) {\n      return undefined;\n    }\n\n    const reader = new WkbReader(view);\n    reader.readWkbHeader();\n\n    return (\n      (reader.getSrid() && getProjection('EPSG:' + reader.getSrid())) ||\n      undefined\n    );\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeature(feature, opt_options) {\n    return this.writeGeometry(feature.getGeometry(), opt_options);\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeatures(features, opt_options) {\n    return this.writeGeometry(\n      new GeometryCollection(features.map((f) => f.getGeometry())),\n      opt_options\n    );\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeGeometry(geometry, opt_options) {\n    const options = this.adaptOptions(opt_options);\n\n    const writer = new WkbWriter({\n      layout: this.layout_,\n      littleEndian: this.littleEndian_,\n      ewkb: this.ewkb_,\n\n      nodata: {\n        Z: this.nodataZ_,\n        M: this.nodataM_,\n      },\n    });\n\n    // extract SRID from `dataProjection`\n    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n      const dataProjection =\n        options.dataProjection && getProjection(options.dataProjection);\n      if (dataProjection) {\n        const code = dataProjection.getCode();\n        if (code.indexOf('EPSG:') === 0) {\n          srid = Number(code.substring(5));\n        }\n      }\n    }\n\n    writer.writeGeometry(\n      transformGeometryWithOptions(geometry, true, options),\n      srid\n    );\n    const buffer = writer.getBuffer();\n\n    return this.hex_ ? encodeHexString(buffer) : buffer;\n  }\n}\n\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\nfunction encodeHexString(buffer) {\n  const view = new Uint8Array(buffer);\n  return Array.from(view.values())\n    .map((x) => (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase())\n    .join('');\n}\n\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\nfunction decodeHexString(text) {\n  const buffer = new Uint8Array(text.length / 2);\n  for (let i = 0; i < text.length / 2; i++) {\n    buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n  }\n  return new DataView(buffer.buffer);\n}\n\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\nfunction getDataView(source) {\n  if (typeof source === 'string') {\n    return decodeHexString(source);\n  } else if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  } else if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  } else {\n    return null;\n  }\n}\n\nexport default WKB;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport WKB from '../src/ol/format/WKB.js';\nimport {OSM, Vector as VectorSource} from '../src/ol/source.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\n\nconst raster = new TileLayer({\n  source: new OSM(),\n});\n\nconst wkb =\n  '0103000000010000000500000054E3A59BC4602540643BDF4F8D1739C05C8FC2F5284C4140EC51B81E852B34C0D578E926316843406F1283C0CAD141C01B2FDD2406012B40A4703D0AD79343C054E3A59BC4602540643BDF4F8D1739C0';\n\nconst format = new WKB();\n\nconst feature = format.readFeature(wkb, {\n  dataProjection: 'EPSG:4326',\n  featureProjection: 'EPSG:3857',\n});\n\nconst vector = new VectorLayer({\n  source: new VectorSource({\n    features: [feature],\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: 'map',\n  view: new View({\n    center: [2952104.0199, -3277504.823],\n    zoom: 4,\n  }),\n});\n"],"sourceRoot":""}