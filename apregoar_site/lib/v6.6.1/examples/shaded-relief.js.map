{"version":3,"sources":["webpack:///./shaded-relief.js"],"names":["const","elevation","url","crossOrigin","raster","sources","operationType","operation","inputs","data","pixelX","pixelY","x1","y0","y1","offset","z0","dzdx","dzdy","slope","aspect","scaled","elevationImage","width","height","elevationData","shadeData","Uint8ClampedArray","length","dp","resolution","maxX","maxY","pixel","twoPi","Math","PI","halfPi","sunEl","sunAz","cosSunEl","cos","sinSunEl","sin","calculateElevation","vert","atan","sqrt","atan2","controls","target","layers","source","opacity","view","extent","center","minZoom","maxZoom","zoom","forEach","id","control","document","getElementById","output","addEventListener","innerText","value","changed","on","event","Number"],"mappings":"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","file":"shaded-relief.js","sourcesContent":["import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from '../src/ol/layer.js';\nimport {OSM, Raster, XYZ} from '../src/ol/source.js';\n\n/**\n * Generates a shaded relief image given elevation data.  Uses a 3x3\n * neighborhood for determining slope and aspect.\n * @param {Array<ImageData>} inputs Array of input images.\n * @param {Object} data Data added in the \"beforeoperations\" event.\n * @return {ImageData} Output image.\n */\nfunction shade(inputs, data) {\n  const elevationImage = inputs[0];\n  const width = elevationImage.width;\n  const height = elevationImage.height;\n  const elevationData = elevationImage.data;\n  const shadeData = new Uint8ClampedArray(elevationData.length);\n  const dp = data.resolution * 2;\n  const maxX = width - 1;\n  const maxY = height - 1;\n  const pixel = [0, 0, 0, 0];\n  const twoPi = 2 * Math.PI;\n  const halfPi = Math.PI / 2;\n  const sunEl = (Math.PI * data.sunEl) / 180;\n  const sunAz = (Math.PI * data.sunAz) / 180;\n  const cosSunEl = Math.cos(sunEl);\n  const sinSunEl = Math.sin(sunEl);\n  let pixelX,\n    pixelY,\n    x0,\n    x1,\n    y0,\n    y1,\n    offset,\n    z0,\n    z1,\n    dzdx,\n    dzdy,\n    slope,\n    aspect,\n    cosIncidence,\n    scaled;\n  function calculateElevation(pixel) {\n    // The method used to extract elevations from the DEM.\n    // In this case the format used is\n    // red + green * 2 + blue * 3\n    //\n    // Other frequently used methods include the Mapbox format\n    // (red * 256 * 256 + green * 256 + blue) * 0.1 - 10000\n    // and the Terrarium format\n    // (red * 256 + green + blue / 256) - 32768\n    //\n    return pixel[0] + pixel[1] * 2 + pixel[2] * 3;\n  }\n  for (pixelY = 0; pixelY <= maxY; ++pixelY) {\n    y0 = pixelY === 0 ? 0 : pixelY - 1;\n    y1 = pixelY === maxY ? maxY : pixelY + 1;\n    for (pixelX = 0; pixelX <= maxX; ++pixelX) {\n      x0 = pixelX === 0 ? 0 : pixelX - 1;\n      x1 = pixelX === maxX ? maxX : pixelX + 1;\n\n      // determine elevation for (x0, pixelY)\n      offset = (pixelY * width + x0) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z0 = data.vert * calculateElevation(pixel);\n\n      // determine elevation for (x1, pixelY)\n      offset = (pixelY * width + x1) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z1 = data.vert * calculateElevation(pixel);\n\n      dzdx = (z1 - z0) / dp;\n\n      // determine elevation for (pixelX, y0)\n      offset = (y0 * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z0 = data.vert * calculateElevation(pixel);\n\n      // determine elevation for (pixelX, y1)\n      offset = (y1 * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z1 = data.vert * calculateElevation(pixel);\n\n      dzdy = (z1 - z0) / dp;\n\n      slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy));\n\n      aspect = Math.atan2(dzdy, -dzdx);\n      if (aspect < 0) {\n        aspect = halfPi - aspect;\n      } else if (aspect > halfPi) {\n        aspect = twoPi - aspect + halfPi;\n      } else {\n        aspect = halfPi - aspect;\n      }\n\n      cosIncidence =\n        sinSunEl * Math.cos(slope) +\n        cosSunEl * Math.sin(slope) * Math.cos(sunAz - aspect);\n\n      offset = (pixelY * width + pixelX) * 4;\n      scaled = 255 * cosIncidence;\n      shadeData[offset] = scaled;\n      shadeData[offset + 1] = scaled;\n      shadeData[offset + 2] = scaled;\n      shadeData[offset + 3] = elevationData[offset + 3];\n    }\n  }\n\n  return {data: shadeData, width: width, height: height};\n}\n\nconst elevation = new XYZ({\n  url: 'https://{a-d}.tiles.mapbox.com/v3/aj.sf-dem/{z}/{x}/{y}.png',\n  crossOrigin: 'anonymous',\n});\n\nconst raster = new Raster({\n  sources: [elevation],\n  operationType: 'image',\n  operation: shade,\n});\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM(),\n    }),\n    new ImageLayer({\n      opacity: 0.3,\n      source: raster,\n    }),\n  ],\n  view: new View({\n    extent: [-13675026, 4439648, -13580856, 4580292],\n    center: [-13615645, 4497969],\n    minZoom: 10,\n    maxZoom: 16,\n    zoom: 13,\n  }),\n});\n\nconst controlIds = ['vert', 'sunEl', 'sunAz'];\nconst controls = {};\ncontrolIds.forEach(function (id) {\n  const control = document.getElementById(id);\n  const output = document.getElementById(id + 'Out');\n  control.addEventListener('input', function () {\n    output.innerText = control.value;\n    raster.changed();\n  });\n  output.innerText = control.value;\n  controls[id] = control;\n});\n\nraster.on('beforeoperations', function (event) {\n  // the event.data object will be passed to operations\n  const data = event.data;\n  data.resolution = event.resolution;\n  for (const id in controls) {\n    data[id] = Number(controls[id].value);\n  }\n});\n"],"sourceRoot":""}